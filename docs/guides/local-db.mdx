---
title: "Local Database Setup"
description: "Set up PostgreSQL for Suga local development."
---

This guide shows you how to set up PostgreSQL for local development with your Suga project.

<Note>
  **Prerequisites:** This guide assumes you have an existing Suga project with a service that needs database access. If you need to create a project, see our [Getting Started Guide](/quickstart).
</Note>

## Step 1: Setup PostgreSQL with Docker

Create a `docker-compose.yml` file in your project root:

```yaml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secure_password}
      POSTGRES_DB: ${POSTGRES_DB:-myapp}
    ports:
      - '5433:5432'
    volumes:
      - postgres_data:/var/lib/postgresql/data
    command: postgres -c ssl=off

volumes:
  postgres_data:
```

Create an `.env` file with local credentials:

```bash
POSTGRES_USER=admin
POSTGRES_PASSWORD=secure_password
POSTGRES_DB=myapp
```

<Note>
  **Security:** Change the default password before using in any shared environment.
</Note>

Add database commands to your `Makefile`:

```makefile
.PHONY: db-start db-stop db-reset

db-start:
	@echo "üê≥ Starting database..."
	@docker compose up -d
	@echo "‚úÖ Database ready!"

db-stop:
	@echo "üõë Stopping database..."
	@docker compose down

db-reset:
	@echo "üîÑ Resetting database..."
	@docker compose down -v
	@docker compose up -d
	@sleep 2
	@docker compose exec -T postgres psql -U admin -d myapp < init.sql
	@echo "‚úÖ Database reset with fresh data!"
```

Start your database:

```bash
make db-start
```

## Step 2: Configure Database in Suga

Open the Suga dashboard:

```bash
suga edit
```

Drag a database resource onto your project canvas and connect it to your service. Set the environment key to `DATABASE_URL`.

![Database Configuration](/images/database.png)

This automatically updates your `suga.yaml`:

```yaml
name: test-db
description: Simple project to test our local database
targets: []
services:
  app:
    container:
      docker:
        dockerfile: Dockerfile
        context: .
    dev:
      script: go run main.go
entrypoints:
  entrypoint:
    routes:
      /:
        name: app
databases:
  mydb:
    access:
      app:
        - query
    env_var_key: DATABASE_URL
```

Add the connection string to your `.env` file:

```bash
DATABASE_URL=postgresql://admin:secure_password@localhost:5433/myapp?sslmode=disable
```

## Step 3: Initialize Database Schema

Create an `init.sql` file in your project root:

```sql
DROP TABLE IF EXISTS users;

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO users (email) VALUES
  ('admin@example.com'),
  ('user@example.com');
```

Apply your schema:

```bash
make db-reset
```

<Note>
  For production, use a proper migration tool like golang-migrate, Flyway, or your ORM's migration system.
</Note>

## Step 4: Test Your Database Connection

Install the required dependencies:

```bash
go get github.com/lib/pq
go get github.com/joho/godotenv
```

Update your `main.go` to include database support:

```go
package main

import (
  "database/sql"
  "encoding/json"
  "log"
  "net/http"
  "os"

  "github.com/joho/godotenv"
  _ "github.com/lib/pq"
)

func main() {
  // Load .env file
  _ = godotenv.Load()

  // Connect to database
  dbURL := os.Getenv("DATABASE_URL")
  db, err := sql.Open("postgres", dbURL)
  if err != nil {
    log.Fatalf("Failed to connect to database: %v", err)
  }
  defer db.Close()

  // Test connection
  if err := db.Ping(); err != nil {
    log.Fatalf("Failed to ping database: %v", err)
  }

  // Create router
  router := http.NewServeMux()

  // Add users endpoint
  router.HandleFunc("GET /users", func(w http.ResponseWriter, r *http.Request) {
    rows, err := db.Query("SELECT id, email, created_at FROM users")
    if err != nil {
      http.Error(w, err.Error(), 500)
      return
    }
    defer rows.Close()

    var users []map[string]interface{}
    for rows.Next() {
      var id int
      var email, createdAt string
      if err := rows.Scan(&id, &email, &createdAt); err != nil {
        http.Error(w, err.Error(), 500)
        return
      }
      users = append(users, map[string]interface{}{
        "id":         id,
        "email":      email,
        "created_at": createdAt,
      })
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
  })

  log.Println("Server starting on :3000")
  log.Fatal(http.ListenAndServe(":3000", router))
}
```

Start your application:

```bash
suga dev
```

Test the endpoint in another terminal:

```bash
curl http://localhost:3000/users
```

You should see your user data:

```json
[
  {"id":1,"email":"admin@example.com","created_at":"2025-08-14T17:12:05Z"},
  {"id":2,"email":"user@example.com","created_at":"2025-08-14T17:12:05Z"}
]
```

<Note>
  Stop the database when finished: `make db-stop`
</Note>

## Next Steps

- For production, configure your `DATABASE_URL` with your cloud provider (Neon, Supabase, RDS, etc.)
- Consider using migration tools like golang-migrate or Flyway for schema management
- Add proper error handling and connection pooling for production use
